// -----------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------
// การประกาศฟังก์ชัน !!!
// การประกาศฟั่งก์ชัน เป็นวิธีพื้นฐานในการกําหนดฟั งก์ชันใน JavaScript วิธีนี้ช่วยให้คุณสามารถสร้างฟั งก์ชันที่สามารถเรียก
// ใช้ได้ทุกที่ในสคริปต์หลังจากที่มันถูกประกาศ เนื่องจากกระบวนการที่เรียกว่า ”hoisting”
// -----------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------
// ไวยากรณ์ของการประกาศฟังก์ชัน: Function Declaration Syntax/////////////////////////////////////////
function functionName(parameters){
    //code to be executed
}

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของการประกาศฟังก์ชันอย่างง่าย:Simple Function Declaration Example ////////////////////////////
function greet(name){
    return "Hello, " + name + "!";
};

console.log(greet("Alice")); // output: Hello, Alice!

// -----------------------------------------------------------------------------------------------
// นิพจน์ฟังก์ชัน !!! 
// นิพจน์ ฟังก์ชัน คือ การสร้างฟังก์ชันและกําหนดให้กับตัวแปร ไม่เหมือนการประกาศฟังก์ชันนิพจน์ฟังก์ชันไม่ได้ถูกยกขึ้น
// (hoisted) ซึ่งหมายความว่ามันไม่สามารถเรียกใช้ได้ก่อนที่จะถูกกําหนด
// ไวยากรณ์ของนิพจน์ฟังก์ชัน:Function Expression Syntax //////////////////////////////////////////////
const functionName = function(parameters) {
    //code to be executed
};

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของนิพจน์ฟังก์ชัน:Function Expression Example //////////////////////////////////////////////
const greet = function(name){
    return "Hello, " + name + "!";
};
console.log(greet("Bob")); //Output: Hello, Bob!

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของนิพจน์ฟังก์ชันที่ไม่ระบุชื่อ:Anonymous Function Expression Example ////////////////////////////
setTimeout(function(){
    console.log("This message will display after 3 seconds");
}, 3000);

// -----------------------------------------------------------------------------------------------
// ในตัวอย่างนี้ ฟังก์ชันที่ไม่ระบุชื่อถูกส่งผ่านเป็นพารามิเตอร์ให้กับฟังก์ชัน setTimeout ซึ่งจะดําเนินการโค้ดภายในฟังก์ชันที่ไม่ระบุชื่อหลังจากเวลาที่กําหนด
// -----------------------------------------------------------------------------------------------
// ฟังก์ชันลูกศร
// ฟังก์ชันลูกศร ถูกแนะนําใน ES6 (ECMAScript 2015) เป็นวิธีที่กระชับกว่าในการเขียนฟังก์ชันใน JavaScript ฟังก์ชันลูกศร
// ช่วยทําให้ไวยากรณ์ของฟังก์ชันเรียบง่ายขึ้น โดยเฉพาะเมื่อฟังก์ชันมีขนาดเล็ก นอกจากนี้ยังจัดการกับคีย์เวิร์ด this แตกต่าง
// จากฟั งก์ชันทั่วไป ซึ่งสามารถเป็นประโยชน์ในบางสถานการณ์

// -----------------------------------------------------------------------------------------------
// ไวยากรณ์ของฟั งก์ชันลูกศร: Arrow Function Syntax //////////////////////////////////////////////////
const functionName = (parameters) => {
    //code to be executed
};

// -----------------------------------------------------------------------------------------------
// สําหรับฟังก์ชันที่มีพารามิเตอร์เดียว สามารถละเว้นวงเล็บได้: Concise Arrow Function Syntax ////////////////////
const greet = name => "Hello, " + name + "!";

// -----------------------------------------------------------------------------------------------
// ในตัวอย่างนี้ ฟังก์ชัน multiply ถูกกําหนดด้วยไวยากรณ์ฟังก์ชันลูกศร โดยรับพารามิเตอร์สองตัวคือ a และ b และคืน ค่าผลคูณของพวกมัน
// ฟังก์ชันลูกศรมีประโยชน์อย่างยิ่งในสถานการณ์ที่คุณต้องส่งผ่านฟั งก์ชันเป็นอาร์กิวเมนต์ เช่นในเมธอดของอาเรย์เช่น map, filter, และ reduce

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของฟั งก์ชันลูกศรในเมธอดของอาเรย์: Arrow Function in Array Methods Example ///////////////////
const numbers = [1, 2, 3, 4, 5];
const squares = numbers.map(number => number * number);
console.log(squares); // Output: [1, 4, 9, 16, 25]

// -----------------------------------------------------------------------------------------------
// ในตัวอย่างนี้ เมธอด map นําฟังก์ชันลูกศรไปใช้กับแต่ละองค์ประกอบในอาเรย์ numbers ส่งผลให้เกิดอาเรย์ใหม่ที่ประกอบด้วยค่าที่ถูกยกกําลังสอง
// ฟังก์ชันลูกศรต่างจากฟังก์ชันทั่วไปในวิธีการจัดการกับคีย์เวิร์ด this ในฟังก์ชันปกติ this จะอ้างถึงออบเจกต์ที่เรียกใช้ฟังก์ชันซึ่งอาจแตกต่างกันไปขึ้นอยู่กับบริบท 
// อย่างไรก็ตามในฟังก์ชันลูกศร this ถูกผูกติดตามตัวอักษรซึ่งหมายความว่ามันจะเก็บค่าของ this จากบริบทโดยรอบ

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของ this ในฟังก์ชันลูกศร: Arrow Function ‘this‘ Binding Example ///////////////////////////
function Person(name) {
    this.name = name;
    this.sayName = () => {
        console.log(this.name);
    };
}
const person1 = new Person("Chalie");
person1.sayName(); // Output: Charlie

// ในตัวอย่างนี้ ฟังก์ชันลูกศรใน sayName ใช้ค่า this จากตัวสร้าง Person ทําให้มันอ้างอิงถึงอินสแตนซ์ของ Person ได้อย่างถูกต้อง
// ฟังก์ชันลูกศรเป็นฟีเจอร์ที่มีพลังใน JavaScript โดยมอบไวยากรณ์ที่สะอาดและอ่านง่ายสําหรับการกําหนดฟังก์ชัน โดยเฉพาะในกรณีที่ฟังก์ชันปกติจะต้องใช้โค้ดที่ซับซ้อนมากขึ้น

// -----------------------------------------------------------------------------------------------
// การสร้างออบเจกต์ด้วย Object Literals: 
// ในตัวอย่างนี้ ออบเจกต์person มีคุณสมบัติสองอย่าง (name และ age) และมีเมธอดหนึ่งอย่าง (greet) เมธอดนี้ใช้ คีย์เวิร์ด this เพื่ออ้างอิงถึงคุณสมบัติของออบเจกต์
const person = {
    name: "David",
    age: 25,
    greet: function(){
        console.log("Hello, my name is " + this.name);
    }
};
console.log(person.name);
person.greet(); // Output: Hello, my name is David

// ตัวอย่างของการเข้าถึงคุณสมบัติ: คุณยังสามารถเพิ่ม, อัปเดต, หรือลบคุณสมบัติได้อย่างไดนามิก:
console.log(person.name); // Output: David
console.log(person["age"]); // Output: 25

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของการปรับเปลี่ยนคุณสมบัติ: 
// ในตัวอย่างนี้ คุณสมบัติname ถูกอัปเดต, คุณสมบัติjob ใหม่ถูกเพิ่ม และคุณสมบัติage ถูกลบ เมธอด เป็นฟั งก์ชันที่เป็นส่วนหนึ่งของออบเจกต์และ
// มักใช้ในการดําเนินการกับคุณสมบัติของออบเจกต์ เมธอดสามารถกําหนดได้โดยตรงภายใน Object Literal หรือเพิ่มเข้าไปอย่างไดนามิก:
person.name = "John";
person.job = "Engineer";
delete person.age;
console.log(person); // Output: {name: "John", greet: [function: greet], job: "Engineer"}

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของการกําหนดเมธอด: 
// ในตัวอย่างนี้ ออบเจกต์car มีเมธอด start ที่พิมพ์ข้อความเมื่อถูกเรียกใช้
const car = {
    brand: "Toyota",
    model: "Corolla",
    start: function(){
        console.log("This car is starting");
    }
};
car.start(); //Output: The car is ctarting

// -----------------------------------------------------------------------------------------------
// การสร้างออบเจกต์ด้วย Constructor Functions:
// Constructor functions เป็นวิธีที่ใช้บ่อยในการสร้างออบเจกต์ที่มีโครงสร้างเดียวกัน พวกมันช่วยให้คุณสามารถกําหนดโครง
// ร่างสําหรับออบเจกต์และสร้างอินสแตนซ์หลายตัวที่มีคุณสมบัติและเมธอดที่คล้ายกัน

// ในตัวอย่างนี้ ฟั งก์ชัน Animal เป็นฟั งก์ชันสร้างที่กําหนดโครงร่างสําหรับการสร้างสัตว์ เมธอด speak ถูกเพิ่มเข้าไปใน
// Animal.prototype ทําให้อินสแตนซ์ของ Animal ทุกตัวสามารถแชร์เมธอดนี้ได้
function Animal(name, spacies){
    this.name = name;
    this.spacies = spacies;
}
Animal.prototype.speak = function(){
    console.log(this.name + " says Hello!");
};

const dog = new Animal("Buddy", "Dog");
const cat = new Animal("Whiskers", "Cat");

dog.speak(); // output: Buddy says Hello!
cat.speak(); // Output: Whiskers says Hello!

// -----------------------------------------------------------------------------------------------
// การสืบทอดด้วย Object.create 
// อีกวิธีหนึ่งในการสืบทอดใน JavaScript คือผ่านเมธอด Object.create ซึ่งช่วยให้คุณสามารถสร้างออบเจกต์ใหม่ที่สืบทอดจากออบเจกต์โปรโตไทป์ที่กําหนด

// ในตัวอย่างนี้ ออบเจกต์ dog ถูกสร้างด้วย animal เป็นโปรโตไทป์ ของมัน โดยสืบทอดเมธอด speak จากออบเจกต์
// animal
const animal = {
    speak: function(){
        console.log(this.name + "makes a sound");
    }
};
const dogs = Object.create(animal);
dogs.name = "Buddy";
dogs.speak(); // Output: Buddy makes a sound

// -----------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------
// Prototype Chain คืออะไร?
// Prototype Chain เป็นกลไกที่ JavaScript ใช้ในการสืบทอดคุณสมบัติและเมธอดจากออบเจกต์หนึ่งไปยังอีกออบเจกต์หนึ่ง
// ออบเจกต์ทุกตัวใน JavaScript มีโปรโตไทป์ซึ่งเป็นออบเจกต์อีกตัวหนึ่งที่สามารถสืบทอดคุณสมบัติและเมธอดได้ โซ่ของโปรโต
// ไทป์นี้จะดําเนินต่อไปจนถึงโปรโตไทป์ null ซึ่งเป็นจุดสิ้นสุดของโซ่
// -----------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------------------
// ตัวอย่างของ Prototype Chain:
// ในตัวอย่างนี้ ออบเจกต์ alice เป็นอินสแตนซ์ของ Person เมธอด greet ไม่ได้อยู่ใน alice โดยตรง แต่ในโปร
// โตไทป์ ของมันซึ่งก็คือ Person.prototype ตัวอย่างนี้แสดงให้เห็นว่าคุณสมบัติและเมธอดถูกสืบทอดผ่านโซ่โปรโตไทป์ ได้อย่างไร
function person(name){
    this.name = name;
}
person.prototype.greet = function(){
    console.log("Hello, " + this.name);
};
const alice = new person("Alice");

console.log(alice.hasOwnProperty("name")); // true
console.log(alice.hasOwnProperty("greet")); // false
console.log(alice.hasOwnProperty(alice)); // person {greet: [function] }

// -----------------------------------------------------------------------------------------------
// ตัวอย่างของ__proto__และprototype:
// ในตัวอย่างนี ้ออบเจกต์ student สืบทอดจากออบเจกต์ person โดยตั้งค่า student.__proto__เป็นperson
// ผลลัพธ์คือ student สามารถเข้าถึงคุณสมบัติ name และเมธอด greet จาก person ได้
const person = {
    name: "John",
    greet: function(){
        console.log("Hello, " + this.name);
    }
};

const student = {
    course: "Math"
};

student.__proto__ = person;

console.log(student.name);
student.greet();
